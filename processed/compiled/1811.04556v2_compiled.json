{
  "metadata": {
    "title": "HPS: A C++11 High Performance Serialization Library",
    "authors": [
      "Junhao Li"
    ],
    "abstract": "Data serialization is a common and crucial component in high performance computing. In this paper, I present a C++11 based serialization library for performance critical systems. It provides an interface similar to Boost but up to 150% faster and beats several popular serialization libraries.",
    "published": "",
    "arxiv_id": "1811.04556v2",
    "categories": [
      "cs.PF"
    ],
    "pdf_url": "http://arxiv.org/pdf/1811.04556v2",
    "pdf_file": "data/pdfs/1811.04556v2.pdf",
    "pdf_filename": "1811.04556v2.pdf"
  },
  "processing_info": {
    "processed_at": "2025-11-11T10:30:20.264257",
    "is_large_pdf": false,
    "sections_found": 4,
    "tables_found": 10,
    "images_found": 2
  },
  "sections_text": {
    "Abstract": "HPS: A C++ High Performance",
    "Serialization Library": "Junhao Li Department of Physics, Cornell University Data serialization is a common and crucial component in high performance computing. In this paper, I present a C++ based serialization library for performance critical systems. It provides an interface similar to Boost but is upto 1. times faster and beats several popular serialization libraries. Overview Data serialization is a common and crucial component in high performance computing. It is a prerequisite for transferring data over the networks in distributed systems and for storing them on persistence storage devices. The bandwidths of the networks and the storage devices are the bottleneck of many distributed applications, such as MapReduce. Hence, a serialization framework that can produce compact serialized data efficiently can have game-changing impacts on these applications. HPS is designed to and has achieved state of the art performance and beats well-known serialization libraries. Compared to Boost Serialization, HPS is upto 1. times faster and the serialized data from HPS are upto 40% smaller than those from Boost. Compared to Protocol Buffers, HPS is upto 4. times faster for certain types and the serialized data are upto 50% smaller. The interface of HPS is similar to Boost, which means it works on standard containers and user defined structures directly without requiring users to deal with additional tightly coupled serialization classes. This increases code reusability and reduces cognitive efforts for the developers.",
    "Encoding Scheme": "The encoding scheme of HPS is the root of its high performance and compact serialization. I heavily borrow the encoding scheme of Protocol Buffers while removing all the unnecessary fields in a performance critical setting. The resulting scheme contains only data and minimal structural information for recovering the original data unambiguously. The integral types are encoded with basevarints. Signed integrals types use ZigZag encoding before the baseencoding. Hence, if we use HPS to serialize a number, such as -33, the serialized message takes only one byte. The floating point numbers are directly copied from the source memory location to the target. For iterable STL containers, HPS encodes their sizes first, followed by the elements. For custom classes, HPS looks for the serialize and parse methods in these classes. In the following I give two encoding examples: Case #1: A vector of integers #include <cassert> #include <iostream> #include \"../src/hps.h\" int main() { std::vector<unsigned> data({22, 333}); std::string serialized = hps::to_string(data); auto parsed = hps::from_string<std::vector<int>>(serialized); assert(parsed == data); std::cout << \"size (B): \" << serialized.size() << std::endl; // size (B): // Serialized as (in hexadecimal): // (number of elements) // (first number) // cd (first byte of the second number in baseencoding) // (second byte of the second number) return 0; Case #2: Custom Class A Quantum System #include <cassert> #include <iostream> #include \"../src/hps.h\" class QuantumState { public: unsigned n_elecs; std::unordered_set<unsigned> orbs_from; std::unordered_set<unsigned> orbs_to; template <class B> void serialize(B& buf) const { buf << n_elecs << orbs_from << orbs_to; template <class B> void parse(B& buf) { buf >> n_elecs >> orbs_from >> orbs_to; int main() { QuantumState qs; qs.n_elecs = 33; qs.orbs_from.insert({11, 22}); qs.orbs_to.insert({44, 66}); std::string serialized = hps::to_string(qs); std::cout << \"size (B): \" << serialized.size() << std::endl; // size (B): // HPS looks for the serialize<B> and parse<B> in QuantumState. // The first byte is n_elecs, then bytes for each unordered_set. return 0; Compared to Protocol Buffers, HPS does not store data types and field numbers. This reduces the size of the serialized message and also increases the performance. In the extreme case, if the leaf messages contain only non-repeating fields, the serialized message from Protocol Buffers will be times larger than HPS. Implementation There are two key classes in the implementation of HPS, the Serializer and the Buffer. Buffer provides the read/write char(s) interfaces to the Serializer, and provides the \"<<\" and \">>\" operators to the wrapper functions. Serializer<DataType, BufferType> provides the logical serialize and parse methods of the given DataType. It uses the read/write char(s) methods of BufferType to push data to or pull data from the buffer. To make the codebase highly maintainable without sacrificing performance, we heavily use static polymorphism and SFINAE. For example, here is the Serializer specialization for the floating point numbers: template <class T, class B> class Serializer<T, B, typename std::enable_if<std::is_floating_point<T>::value, void>::type> { Public: static void serialize(const T& num, B& ob) { const char* num_ptr = reinterpret_cast<const char*>(&num); ob.write(num_ptr, sizeof(num)); static void parse(T& num, B& ib) { char* num_ptr = reinterpret_cast<char*>(&num); ib.read(num_ptr, sizeof(num)); The wrapper functions call the Serializer to provide an easy to use interface to the users, for example: std::ofstream out_file(\"data.log\", std::ofstream::binary); hps::to_stream(data, out_file); std::ifstream in_file(\"data.log\", std::ifstream::binary); auto parsed = hps::from_stream<std::vector<int>>(in_file); By default, Serializer<DataType, BufferType> will call the serialize<B> and parse<B> methods of the corresponding class. This provides a simple and loosely coupled way of extending HPS for custom classes (See the quantum system case above for example). The complete implementation is hosted at ​ https://github.com/jl2922/hps​ . Benchmark The performance of HPS compared to other well-known C++ serializers for some most common data structures in high performance computing are as follows: (less is better) The sparse matrix is stored as a list of rows, each of which contains a list of 64-bit integers for the column indices and a list of doubles for the values. The hash map is a map from strings to doubles. Both HPS and Boost can serialize std::unordered_map directly, ProtoBuf uses its own Map type and CapnProto does not support hash map or similar types. We can see that HPS is consistently and sometimes significantly faster than Boost and Protocol Buffers. It also beats Capnproto in all the cases except the sparse matrix. However, for the sparse matrix, although Capnproto is faster, the serialized message is also significantly larger, and for large distributed systems, minimizing the size of the data transferred is often more important than minimizing the local CPU time. In addition to the traditional benchmarks for computational cost, we also provide the cognitive effort in terms of source lines of code for these test cases: (less is better) SLOC double array sparse matrix hash map fixed cost protobuf capnproto boost hps Note: fixed cost includes the estimated number of lines of commands needed for an experienced user to install the library, set the environment variables, extra lines of code needed in the Makefile, and various includes, etc. Due to the header-only nature of HPS, it is the easiest one to set up, as we can see from the table above.",
    "Conclusion": "In the paper, I present a high performance serialization library based on C++11. It is easy to use and beats the state of the art performance. Data serialization is important and may be the dominating factor of performance in many applications. HPS enables developers to serialize their structured data to compact binary formats efficiently so that their applications will incur less network traffic and disk operations and thus cost less and run faster. Acknowledgements This work is supported by the U.S. National Science Foundation (NSF) grant ACIand the Air Force Office of Scientific Research (AFOSR) grant FA9550-18-1-0095. We also thank professor Cyrus Umrigar for the helpful suggestions for the paper. Reference Varda, Kenton. \"Protocol buffers: Google’s data interchange format.\" Google Open Source Blog, Available at least as early as Jul (2008). Stuart, Stephen, and Rex Fernando. \"Encoding rules and MIME type for Protocol Buffers.\" (2012). Varda, Kenton. \"Cap’n Proto, 2015.\" URL: https://capnproto.org (2015). Ramey, Robert. \"Boost serialization library.\" URL: Vandevoorde, David, and Nicolai M. Josuttis. C++ Templates. Addison-Wesley Longman Publishing Co., Inc., 2002."
  },
  "sections_summary": {
    "Abstract": "HPS: A C++ High Performance",
    "Serialization Library": "The paper presents a C++ based serialization library called HPS (High Performance Serialization) designed for performance-critical systems. It provides an interface similar to Boost, achieving state-of-the-art performance and beating well-known serialization libraries like Boost Serialization and Protocol Buffers.",
    "Encoding Scheme": "Here's a concise overall summary:\n\nHPS (High-Performance Serialization) is a lightweight serialization framework that optimizes data transmission by removing unnecessary fields for compact storage. It supports serializing integral types, floating-point numbers, iterable containers, and custom classes using a simple interface with functions like `to_stream` and `from_stream`. HPS outperforms popular alternatives such as Boost, Protocol Buffers, and CapnProto in terms of speed, particularly in cases where leaf messages contain only non-repeating fields.",
    "Conclusion": "A high-performance serialization library is presented based on C++11, offering easy-to-use functionality that surpasses state-of-the-art performance. The library enables efficient compact binary formats for structured data, reducing network traffic and disk operations."
  },
  "tables": [
    {
      "page": 1,
      "table_index": 0,
      "content": [
        [
          ""
        ],
        [
          "HPS: A C++11 High Performance\nSerialization Library\nJunhao Li\nDepartment of Physics, Cornell University\nData serialization is a common and crucial component in high performance\ncomputing. In this paper, I present a C++11 based serialization library for\nperformance critical systems. It provides an interface similar to Boost but is upto\n1.5 times faster and beats several popular serialization libraries.\nOverview\nData serialization is a common and crucial component in high performance\ncomputing. It is a prerequisite for transferring data over the networks in\ndistributed systems and for storing them on persistence storage devices. The\nbandwidths of the networks and the storage devices are the bottleneck of many\ndistributed applications, such as MapReduce. Hence, a serialization framework\nthat can produce compact serialized data efficiently can have game-changing\nimpacts on these applications.\nHPS is designed to and has achieved state of the art performance and beats\nwell-known serialization libraries. Compared to Boost Serialization, HPS is upto\n1.5 times faster and the serialized data from HPS are upto 40% smaller than\nthose from Boost. Compared to Protocol Buffers, HPS is upto 4.5 times faster\nfor certain types and the serialized data are upto 50% smaller.\nThe interface of HPS is similar to Boost, which means it works on standard\ncontainers and user defined structures directly without requiring users to deal\nwith additional tightly coupled serialization classes. This increases code\nreusability and reduces cognitive efforts for the developers."
        ],
        [
          ""
        ]
      ]
    },
    {
      "page": 2,
      "table_index": 0,
      "content": [
        [
          ""
        ],
        [
          ""
        ],
        [
          "Encoding Scheme\nThe encoding scheme of HPS is the root of its high performance and compact\nserialization. I heavily borrow the encoding scheme of Protocol Buffers while\nremoving all the unnecessary fields in a performance critical setting. The\nresulting scheme contains only data and minimal structural information for\nrecovering the original data unambiguously.\nThe integral types are encoded with base-128 varints. Signed integrals types\nuse ZigZag encoding before the base-128 encoding. Hence, if we use HPS to\nserialize a number, such as -33, the serialized message takes only one byte.\nThe floating point numbers are directly copied from the source memory location\nto the target. For iterable STL containers, HPS encodes their sizes first,\nfollowed by the elements. For custom classes, HPS looks for the serialize and\nparse methods in these classes.\nIn the following I give two encoding examples:\nCase #1: A vector of integers\n#include <cassert>\n#include <iostream>\n#include \"../src/hps.h\"\nint main() {\nstd::vector<unsigned> data({22, 333});\nstd::string serialized = hps::to_string(data);\nauto parsed = hps::from_string<std::vector<int>>(serialized);\nassert(parsed == data);\nstd::cout << \"size (B): \" << serialized.size() << std::endl;\n// size (B): 7\n// Serialized as (in hexadecimal):\n// 02 (number of elements)\n// 16 (first number)\n// cd (first byte of the second number in base-128 encoding)\n// 02 (second byte of the second number)\nreturn 0;\n}"
        ],
        [
          ""
        ]
      ]
    },
    {
      "page": 3,
      "table_index": 0,
      "content": [
        [
          ""
        ],
        [
          ""
        ],
        [
          "Case #2: Custom Class - A Quantum System\n#include <cassert>\n#include <iostream>\n#include \"../src/hps.h\"\nclass QuantumState {\npublic:\nunsigned n_elecs;\nstd::unordered_set<unsigned> orbs_from;\nstd::unordered_set<unsigned> orbs_to;\ntemplate <class B>\nvoid serialize(B& buf) const {\nbuf << n_elecs << orbs_from << orbs_to;\n}\ntemplate <class B>\nvoid parse(B& buf) {\nbuf >> n_elecs >> orbs_from >> orbs_to;\n}\n};\nint main() {\nQuantumState qs;\nqs.n_elecs = 33;\nqs.orbs_from.insert({11, 22});\nqs.orbs_to.insert({44, 66});\nstd::string serialized = hps::to_string(qs);\nstd::cout << \"size (B): \" << serialized.size() << std::endl;\n// size (B): 7\n// HPS looks for the serialize<B> and parse<B> in QuantumState.\n// The first byte is n_elecs, then 3 bytes for each unordered_set.\nreturn 0;\n}\nCompared to Protocol Buffers, HPS does not store data types and field\nnumbers. This reduces the size of the serialized message and also increases\nthe performance. In the extreme case, if the leaf messages contain only"
        ],
        [
          ""
        ]
      ]
    },
    {
      "page": 4,
      "table_index": 0,
      "content": [
        [
          ""
        ],
        [
          ""
        ],
        [
          "non-repeating fields, the serialized message from Protocol Buffers will be 2\ntimes larger than HPS.\nImplementation\nThere are two key classes in the implementation of HPS, the Serializer and the\nBuffer.\nBuffer provides the read/write char(s) interfaces to the Serializer, and provides\nthe \"<<\" and \">>\" operators to the wrapper functions.\nSerializer<DataType, BufferType> provides the logical serialize and parse\nmethods of the given DataType. It uses the read/write char(s) methods of\nBufferType to push data to or pull data from the buffer. To make the codebase\nhighly maintainable without sacrificing performance, we heavily use static\npolymorphism and SFINAE. For example, here is the Serializer specialization for\nthe floating point numbers:\ntemplate <class T, class B>\nclass Serializer<T, B, typename\nstd::enable_if<std::is_floating_point<T>::value, void>::type> {\nPublic:\nstatic void serialize(const T& num, B& ob) {\nconst char* num_ptr = reinterpret_cast<const char*>(&num);\nob.write(num_ptr, sizeof(num));\n}\nstatic void parse(T& num, B& ib) {\nchar* num_ptr = reinterpret_cast<char*>(&num);\nib.read(num_ptr, sizeof(num));\n}\n};\nThe wrapper functions call the Serializer to provide an easy to use interface to\nthe users, for example:\nstd::ofstream out_file(\"data.log\", std::ofstream::binary);\nhps::to_stream(data, out_file);"
        ],
        [
          ""
        ]
      ]
    },
    {
      "page": 5,
      "table_index": 0,
      "content": [
        [
          ""
        ],
        [
          ""
        ],
        [
          "std::ifstream in_file(\"data.log\", std::ifstream::binary);\nauto parsed = hps::from_stream<std::vector<int>>(in_file);\nBy default, Serializer<DataType, BufferType> will call the serialize<B> and\nparse<B> methods of the corresponding class. This provides a simple and\nloosely coupled way of extending HPS for custom classes (See the quantum\nsystem case above for example).\nThe complete implementation is hosted at ​https://github.com/jl2922/hps.​\nBenchmark\nThe performance of HPS compared to other well-known C++ serializers for\nsome most common data structures in high performance computing are as\nfollows: (less is better)"
        ],
        [
          ""
        ]
      ]
    },
    {
      "page": 6,
      "table_index": 0,
      "content": [
        [
          ""
        ],
        [
          ""
        ],
        [
          "The sparse matrix is stored as a list of rows, each of which contains a list of\n64-bit integers for the column indices and a list of doubles for the values. The\nhash map is a map from strings to doubles. Both HPS and Boost can serialize\nstd::unordered_map directly, ProtoBuf uses its own Map type and CapnProto\ndoes not support hash map or similar types.\nWe can see that HPS is consistently and sometimes significantly faster than\nBoost and Protocol Buffers. It also beats Capnproto in all the cases except the\nsparse matrix. However, for the sparse matrix, although Capnproto is faster, the\nserialized message is also significantly larger, and for large distributed systems,\nminimizing the size of the data transferred is often more important than\nminimizing the local CPU time.\nIn addition to the traditional benchmarks for computational cost, we also\nprovide the cognitive effort in terms of source lines of code for these test\ncases: (less is better)\nSLOC double array sparse matrix hash map fixed cost\nprotobuf 12 23 12 17\ncapnproto 15 25 - 21"
        ],
        [
          ""
        ]
      ]
    },
    {
      "page": 6,
      "table_index": 1,
      "content": [
        [
          "SLOC",
          "double array",
          "sparse matrix",
          "hash map",
          "fixed cost"
        ],
        [
          "protobuf",
          "12",
          "23",
          "12",
          "17"
        ],
        [
          "capnproto",
          "15",
          "25",
          "-",
          "21"
        ]
      ]
    },
    {
      "page": 7,
      "table_index": 0,
      "content": [
        [
          ""
        ],
        [
          ""
        ],
        [
          "boost 13 20 13 13\nhps 7 16 7 2\nNote: fixed cost includes the estimated number of lines of commands needed\nfor an experienced user to install the library, set the environment variables, extra\nlines of code needed in the Makefile, and various includes, etc.\nDue to the header-only nature of HPS, it is the easiest one to set up, as we can\nsee from the table above.\nConclusion\nIn the paper, I present a high performance serialization library based on C++11.\nIt is easy to use and beats the state of the art performance. Data serialization is\nimportant and may be the dominating factor of performance in many\napplications. HPS enables developers to serialize their structured data to\ncompact binary formats efficiently so that their applications will incur less\nnetwork traffic and disk operations and thus cost less and run faster.\nAcknowledgements\nThis work is supported by the U.S. National Science Foundation (NSF) grant\nACI-1534965 and the Air Force Office of Scientific Research (AFOSR) grant\nFA9550-18-1-0095. We also thank professor Cyrus Umrigar for the helpful\nsuggestions for the paper.\nReference\nVarda, Kenton. \"Protocol buffers: Google’s data interchange format.\" Google\nOpen Source Blog, Available at least as early as Jul 72 (2008)."
        ],
        [
          ""
        ]
      ]
    },
    {
      "page": 7,
      "table_index": 1,
      "content": [
        [
          "boost",
          "13",
          "20",
          "13",
          "13"
        ],
        [
          "hps",
          "7",
          "16",
          "7",
          "2"
        ]
      ]
    },
    {
      "page": 8,
      "table_index": 0,
      "content": [
        [
          ""
        ],
        [
          ""
        ],
        [
          "Stuart, Stephen, and Rex Fernando. \"Encoding rules and MIME type for Protocol\nBuffers.\" (2012).\nVarda, Kenton. \"Cap’n Proto, 2015.\" URL: https://capnproto.org (2015).\nRamey, Robert. \"Boost serialization library.\" URL:\nwww.boost.org/doc/libs/release/libs/serialization (2008).\nVandevoorde, David, and Nicolai M. Josuttis. C++ Templates. Addison-Wesley\nLongman Publishing Co., Inc., 2002."
        ]
      ]
    }
  ],
  "images": [
    "processed/images/1811.04556v2_page5_img0.png",
    "processed/images/1811.04556v2_page6_img0.png"
  ],
  "status": "completed"
}